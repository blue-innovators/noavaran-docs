# CQRS و Event Sourcing

<p style="text-align:justify;">
به عنوان یک راهکار به منظور افزایش پرفورمنس و مقیاس پذیری شما شاید بخواهید که materialized view هایی از رویدادهایتان درست کنید. انجام اینکار از اجرای چندین کوئری بصورت همزمان بر روی یک استریم جلوگیری میکند.
با اینکار مقادیر از پیش محاسبه شده برای هر نیاز خاص موجود خواهد بود.
یک سناریو که این مشکل را نشان میدهد زمانی اتفاق می افتد که تعدادی وب پیج همگی کوئری های متفاوتی را بر روی یک استریم اجرا کنند. تصویر زیر این حالت را نشان می دهد.
</P>

<p align="center">
  <img src="/assets/images/event-sourcing-figure-22-7.png" />
</p>

<p style="text-align:justify;">
همانطور که لود وب پیج ها افزایش می یابد هر استریم از رویدادها زیر باز فشار فزاینده ای قرار خواهد گرفت.
این بدین معناست که پیج های کم اهمیت تر ممکن است پروفورمنس وب پیج های مهم را کاهش دهند.
یک راهکار برای این مشکل ساخت یک materialized view از دیتاها به منظور پشتیبانی از وب پیج ها می باشد.
</p>


<p style="text-align:justify;">
راهکار مشکل نشان داده شده در تصویر بالا CQRS می باشد. در این مکانیزم کامند ها یا دستوران write از طریق دامین مدل ها به دامین استریم ها می روند و کوئری ها بر روی materialized view ها یا همان view cacheh ها اجرا میشوند.
با این راهکار خواهید دید که مشکل یک سری یوز کیس هایی که دیگر سناریوها را تحت فشار میگذارند به طرز قابل توجهی کاهش می یابد.
به دلیل ساختار و نحوه مکانیزم این راهکار همچنین فشار بر روی استریم ها به واسطه اجرای کوئری های کمتر بر روی ایشان بسیار کاهش خواهد یافت.
</p>

<p align="center">
  <img src="/assets/images/event-sourcing-figure-22-8.png" />
</p>

<p style="text-align:justify;">
نکته ای که بایستی در این بخش به آن توجه کنید این است که ما تنها به سینرژی مکانیزم CQRS و Event Sourcing خواهیم پرداخت.
به منظور مطالعه درباره جزئیات پیاده سازی CQRS بایستی منابع دیگر مطالعه شوند.
</p>

## 🔸 استفاده از Projection ها برای ساخت View Caches

<p style="text-align:justify;">
به منظور پیاده سازی CQRS با Event Sourcing شما نیازمند راهکاری برای ساخت denormalized view ها از روی استریم ها خواهید بود.
راهکار ساخت این view ها همان Projection ها می باشد که در قسمت های قبلی توضیح داده شده است.
در شکل بالا استفاده از Projection ها را برای مکانیزم CQRS میتوانید مشاهده کنید.
</p>

<p style="text-align:justify;">
همانطور که در داکیومنت این بخش دیده اید اگر از ابزار آماده CQRS استفاده کرده باشید امکانات لازم به منظور ساخت Projection در این ابزار بصورت خودکار وجود دارد.
البته اگر شما Event Store سفارشی خودتان را ساخته باشید لازم است که مقدار زیادی کار انجام دهید تا این قابلیت را پیاده سازی کنید.
خود دیتابیس RavenDB امکان ساخت Projection ها را دارد که میتوانید با سرچ و تحقیق آن را پیاده کنید.
</p>

## 🔸 سینرژی CQRS و Event Sourcing

<p style="text-align:justify;">
اگرچه CQRS و Event Sourcing مفاهیم مستقلی می باشند اما تعداد زیادی از توسعه دهندگان مزیت زیادی را در بکار بردن این دو مکانیزم به همراه هم پیدا کرده اند.
همانطور که دیدید بر پایه مکانیزم Event Sourcing میتوان Projection های از دیتاها درست کرد که باعث میشود جداسازی مدل read و write بصورت ضمنی اتفاق بیفتد و براحتی بتوان CQRS را پیاده سازی کرد.
</p>

### 🔹 استریم رویدادها به عنوان Queue

<p style="text-align:justify;">
در Event Store میتوان استریم های رویدادها را بصورت hypermedia atom feed ارائه داد.
این امکان یک راهکار جایگزین برای استفاده از message bus ها می باشد.
این مزیت ناشی از این است که Event Store رویدادها را بصورت یک صف ذخیره میکند.
</p>

### 🔹 کامیت غیر دو فاز

<p style="text-align:justify;">
از آنجا که Event Store ابزار ذخیره سازی دیتای اصلی، ساخت Projection ها و  تکنولوژی اجرای کوئری شما می باشد نیاز به کامیت های دو فاز وجود ندارد
اگر از SQL Server برای پیاده سازی Event Store خود استفاده کرده بودید به منظور بروزرسانی دیتای View cache ها بایستی از طریق یک message bus رویدادهایی را منتشر میکردید و در سمت دیگر دیتای خود را آپدیت میکردید.
همچنین در این حالت بایستی سناریوهای خطا، مدیریت ایشان و Rollback را نیز در نظر بگیرید.
</p>